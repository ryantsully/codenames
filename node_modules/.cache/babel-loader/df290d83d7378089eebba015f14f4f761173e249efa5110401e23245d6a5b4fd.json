{"ast":null,"code":"// import { useState, useEffect } from 'react';\n\n// // custom hooks in react need to start with \"use\"\n// const useFetch = (url) => {\n//     const [data, setData] = useState(null);\n//     const [isPending, setIsPending] = useState(true);\n//     const [error, setError] = useState(null);\n\n//     // Runs first part on render. Then watches \"name\" and only runs the function if it's changed\n//     useEffect(() => {\n\n//         const abortCont = new AbortController();\n\n//         setTimeout(() => {\n//         // We fetch the data\n//         fetch(url, { signal: abortCont.signal })\n//             .then(res => {\n//                 //Response object\n//                 if (!res.ok) {\n//                     throw Error('could not fetch the data')\n//                 }\n//                 return res.json()\n//             })\n//             .then(data => {\n//                 // getting the data\n//                 setData(data)\n//                 setIsPending(false);\n//                 setError(null);\n//             })\n//             // this catches any network error and fires a function\n//             .catch(err => {\n//                 if (err.main === 'AbortError') {\n//                     console.log(\"Fetch aborted\")\n//                 } else {\n//                 setIsPending(false)\n//                 setError(err.message);\n//                 }\n//             })\n//     }, 1000);\n\n//     return () => abortCont.abort();\n\n// }, [url]);\n\n//     return { data, isPending, error }\n// }\n\n// export default useFetch;","map":{"version":3,"names":[],"sources":["/Users/ryansullivan/Desktop/ryans_workshop/src/pages/useFetch.js"],"sourcesContent":["// import { useState, useEffect } from 'react';\n\n// // custom hooks in react need to start with \"use\"\n// const useFetch = (url) => {\n//     const [data, setData] = useState(null);\n//     const [isPending, setIsPending] = useState(true);\n//     const [error, setError] = useState(null);\n\n//     // Runs first part on render. Then watches \"name\" and only runs the function if it's changed\n//     useEffect(() => {\n\n//         const abortCont = new AbortController();\n\n//         setTimeout(() => {\n//         // We fetch the data\n//         fetch(url, { signal: abortCont.signal })\n//             .then(res => {\n//                 //Response object\n//                 if (!res.ok) {\n//                     throw Error('could not fetch the data')\n//                 }\n//                 return res.json()\n//             })\n//             .then(data => {\n//                 // getting the data\n//                 setData(data)\n//                 setIsPending(false);\n//                 setError(null);\n//             })\n//             // this catches any network error and fires a function\n//             .catch(err => {\n//                 if (err.main === 'AbortError') {\n//                     console.log(\"Fetch aborted\")\n//                 } else {\n//                 setIsPending(false)\n//                 setError(err.message);\n//                 }\n//             })\n//     }, 1000);\n\n//     return () => abortCont.abort();\n\n// }, [url]);\n\n//     return { data, isPending, error }\n// }\n\n// export default useFetch;"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}